#**equal 和 hashcode 作用和区别？**

**首先，我们要明白hashCode()和equals（）方法的作用是什么，然后才能说他的区别，
说了区别之后在说明使用的时候需要注意的地方，这样的回答思路基本是OK的。**
###一、hahsCode()和equals()的作用是什么？
hahsCode()和equals()的作用其实是一样的，目的都是为了再java里面比较两个对象是否相等一致
###二、hahsCode()和equals()的区别是什么？
我们可以从两个角度分别介绍他们的区别：一个是性能，一个是可靠性。他们的主要区别体现在这里
1.equals()既然已经实现比较两个对象的功能了，为什么还需要hashCode()呢？
因为重写的equals()里一般比较的较为全面和复杂(它会对这个对象内所以成员变量一一进行比较)，这样效率很低，而通过hashCode()对比，则只要生成一个hash值就能比较了，效率很高
2.那hashCode的效率这么高，为啥还要用equals()呢？
因为hashCode()并不是完全可靠，非常有可能的情况是，两个完全不同的对象的hash值却是一样的。

所以会有下面三个重要的结论：
*a.equals()相等的两个对象他们的hashCode()肯定相等，即equals()绝对可靠
*b.hahsCode()相同的两个对象，它们的equals()不一定相同。即用hashCode()比较相同的时候不靠谱
*c.hashCode()不同的两个对象，他们的那么equals()肯定不同。即用hashCode()比较不同的时候肯定靠谱

###三、hashCode()和equals使用的注意事项
1.对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方案为：每当需要比较的时候，首先用hahsCode（）去对比，而如果hashCode()不一样，则两个对象肯定不一样，此时就没有必要再用equals()比较了；如果hashCode()相同，则这两个对象有可能相同，这时候再去比较这两个对象的equals()，如若equals()也相同，则表示这两个真的相同的，这样既大大提高了效率，又保证了准确性。
2. 事实上，我们平时用的集合框架中的hashMap、hashSet,hashTable 中对key的比较就是使用上述这种方法。
3. 而Obejct默认的equals和HashCode方法返回的是对象的地址相关信息。所以当我们通过new关键字创建了两个内容相同的对象，虽然他们的内容相同，但是他们在内存中分配的地址不同，导致它们的hashCode()不同，这肯定不是我们想要的。所以当我们要将某个类应用到集合中去的时候，就必须重写equals()方法和hashCode()方法。

###四、扩展
1.阿里巴巴开发规约明确规定：	
*.只要重写了equals()方法，就必须重写hashCode()方法
*.因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法
*.如果对象定义为Map的健，那么就必须重写equals()方法和hashCode()方法
*.String重写了equals()方法和hashCode()方法，所以我们可以非常愉快的时候String对象作为key
2.是不是每个对象都要重写这两个方法，到底什么时候重写？
*.事实上一般情况下，我们并不需要重写这两个方法，只有该类被应用到集合框架中去的时候，才应该重写。
3.我能不能只重写equals()方法，不重写hashCode()方法？
*.如果重写了equals()方法，比如说基于对象的内容实现的，而保留了hashCode()的实现不改变，那么最终出现的情况很可能是，两个对象明明是“相等的”，但是hashCode()却不一样，这不是宝宝想要的
4.为什么需要hashCode
*.通过hashCode可以提高对比的性能
